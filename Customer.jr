import edu.ucdavis.jr.*;

public class Customer {
  private cap void (cap Resource (Constants.Order)) orderQueue;
  private cap void (cap void ()) handShake;
  private cap Resource (Constants.Order) order;
  private cap void () lastCall;
  private cap void (Cupboard.Glass) putGlass;
  private cap void (Cupboard.Cup) putCup;
  
  private Resource drink;
  
  private boolean closed;
  
  public Customer(cap void (cap Resource (Constants.Order)) orderQueue, cap void (cap void ()) handShake, Table favouriteTable) {
    this.orderQueue = orderQueue;
    this.handShake = handShake;
    
    putCup = favouriteTable.getPutCup();
    putGlass = favouriteTable.getPutGlass();
    
    lastCall = new op void ();
    order = new op Resource (Constants.Order);
    closed = false;
    
    send handShake(lastCall);
  }
  
  /* Perhaps last order situations can be solved by having a boolean that checks whether the bar has closed. */
  process mainLoop {
    Constants.Order randomOrder;
    while (!closed) {
      send orderQueue(order);
      randomOrder = Constants.Order.BEER;
      //randomOrder = Constants.Order.getOrder((int) Math.random()*3);
      drink = order(randomOrder);
      System.out.println("I received a drink!");
      // Go to table
      // Drink
      JR.nap(Constants.DRINK_TIME);
      // Set drink to table IF IT ISN'T ALREADY GONE
      if (this.drink != null) {
        if (drink instanceof Cupboard.Cup) {
          call putCup((Cupboard.Cup) drink);
        } else {
          call putGlass((Cupboard.Glass) drink);
        }
      }
      System.out.println("I put down my drink");
      // Repeat
    }
  }
  
  process checkLastCall {
    receive lastCall();
    doTheLastOrder();
  }
  
  private void doTheLastOrder() {
    // Set down your current drink immediatly and place a new order
    
  }
}
import edu.ucdavis.jr.*;

public class Customer {
	private cap Resource (Constants.Order) orderQueue;
	private cap void (cap void ()) handShake;
	private op Resource order (Constants.Order) ;
	private op void lastCall ();
	private cap void (ServingArea.Glass) putGlass;
	private cap void (ServingArea.Cup) putCup;

	private Resource drink;
	private Clock clock;

	private int numberOfDrinks;

	private op void alarm ();
	private op void isDrinking (boolean);
	private Constants.Order myOrder;
	
	boolean drinker;
	
	public Customer(cap Resource (Constants.Order) orderQueue,
									cap void (cap void ()) handShake,
									Table favouriteTable, Clock clock) {
		this.orderQueue = orderQueue;
		this.handShake = handShake;
		this.clock = clock;

		putCup = favouriteTable.getPutCup();
		putGlass = favouriteTable.getPutGlass();

		numberOfDrinks = 0;
    drinker = false;

		myOrder = Constants.Order.values()[(int) (Math.random() * 3)];

		send handShake(lastCall);
	}

	/* Perhaps last order situations can be solved by having a boolean that checks whether the bar has closed. */
	process mainLoop {



		while (numberOfDrinks < Constants.MAX_DRINKS) {
			
			drink = orderQueue(myOrder);
			if (drink instanceof ServingArea.Refusal) {
			  System.out.println("------------------>> I was refused!!!! I'll return later with an AK-47 and blast the place.");
			  break;
		  }
			numberOfDrinks++;
			System.out.println("I received a drink!");
			// Go to table
			// Drink
			send isDrinking(true);
			send clock.setAlarm(alarm, Constants.DRINK_TIME);
			receive alarm();
			send isDrinking(false);
			// Set drink to table IF IT ISN'T ALREADY GONE
			if (drink instanceof ServingArea.Cup) {
				call putCup((ServingArea.Cup) drink);
			} else {
				call putGlass((ServingArea.Glass) drink);
			}
			System.out.println("I put down my drink");
			// Repeat
		}
		System.out.println("Customer going home.");
		send handShake(lastCall);
	}

	process checkLastCall { //may need semaphores for this, later issue

		receive lastCall();

		//it is assured that the customer is drinking if isDrinking op contains a message
		if(numberOfDrinks < Constants.MAX_DRINKS && myOrder.equals(Constants.Order.BEER) && drinker){
			numberOfDrinks = 4;
			send alarm();
			receive alarm();
		}

	} 
	
	process drinkCheck {
	  while (true) {
	    receive isDrinking(drinker);
	  }
	}

}
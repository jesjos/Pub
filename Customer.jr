import edu.ucdavis.jr.*;

public class Customer {
  private cap Resource (Constants.Order) orderQueue;
  private cap void (cap void ()) handShake;
  private cap Resource (Constants.Order) order;
  private cap void () lastCall;
  private cap void (ServingArea.Glass) putGlass;
  private cap void (ServingArea.Cup) putCup;
  
  private Resource drink;
  private Clock clock;
  
  private int numberOfDrinks;
  
  private boolean closed;
  
  public Customer(cap Resource (Constants.Order) orderQueue, cap void (cap void ()) handShake, Table favouriteTable, Clock clock) {
    this.orderQueue = orderQueue;
    this.handShake = handShake;
    this.clock = clock;
    
    putCup = favouriteTable.getPutCup();
    putGlass = favouriteTable.getPutGlass();
    
    lastCall = new op void ();
    order = new op Resource (Constants.Order);
    closed = false;
    numberOfDrinks = 0;
    
    send handShake(lastCall);
  }
  
  /* Perhaps last order situations can be solved by having a boolean that checks whether the bar has closed. */
  process mainLoop {
    op void alarm ();
    
    Constants.Order randomOrder;
    while (!closed && (numberOfDrinks < Constants.MAX_DRINKS)) {
      randomOrder = Constants.Order.BEER;
      drink = orderQueue(randomOrder);
      numberOfDrinks++;
      System.out.println("I received a drink!");
      // Go to table
      // Drink
      send clock.setAlarm(alarm, Constants.DRINK_TIME);
      receive alarm();
      // Set drink to table IF IT ISN'T ALREADY GONE
      if (this.drink != null) {
        if (drink instanceof ServingArea.Cup) {
          call putCup((ServingArea.Cup) drink);
        } else {
          call putGlass((ServingArea.Glass) drink);
        }
      }
      System.out.println("I put down my drink");
      // Repeat
    }
  }
  
  process checkLastCall {
    receive lastCall();
    doTheLastOrder();
  }
  
  private void doTheLastOrder() {
    // Set down your current drink immediatly and place a new order
    
  }
}